HTTP（HyperText Transfer Protocol，超文本传输协议）是用于在客户端和服务器之间传输超文本的协议，是万维网（World Wide Web）通信的基础。

HTTP 是一种[应用程序层](https://www.cloudflare.com/learning/ddos/application-layer-ddos-attack/)协议，旨在在联网设备之间传输信息，并在网络[协议](https://www.cloudflare.com/learning/network-layer/what-is-a-protocol/)栈的其他层之上运行。HTTP 上的一个典型工作流程是客户端计算机向服务器发出请求，然后服务器发送响应消息。

## HTTP 协议的基本结构

HTTP 是一种**无状态**的请求-响应协议，这意味着每次请求都是独立的，服务器不会保留之前请求的状态。HTTP 的工作流程包括以下几个步骤：

1. **客户端发起请求**：客户端（通常是浏览器）向服务器发送一个 HTTP 请求，通常通过 **URL**（统一资源定位符）指定要访问的资源。
2. **服务器处理请求**：服务器接收到请求后，处理请求并返回相应的 HTTP 响应。
3. **客户端接收响应**：客户端接收服务器返回的响应并呈现给用户（如在浏览器中显示网页）。

## HTTP 请求的组成部分

- **请求行**：包括请求方法（如 GET、POST 等）、请求的资源路径、以及 HTTP 版本号。例如：`GET /index.html HTTP/1.1`
- **请求头（Headers）**：包含有关请求的信息，如浏览器类型、请求的主机名、用户[[代理]]、内容类型等。例如：

```makefile
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
```

- **请求体（Body）**：用于在 POST 或 PUT 请求中传输数据，如表单数据、JSON、XML 等。GET 请求通常没有请求体。

## 常见的 HTTP 方法

- **GET**：请求服务器返回指定资源，常用于请求网页内容。GET 请求的参数通常附在 URL 中。
- **POST**：向服务器提交数据，常用于提交表单或上传文件。POST 请求的参数放在请求体中。
- **PUT**：用于更新服务器上的资源，通常用来上传新的内容。
- **DELETE**：用于删除服务器上的资源。
- **HEAD**：与 GET 类似，但只请求资源的响应头，不返回响应体。
- **OPTIONS**：用于查询服务器支持的 HTTP 方法。

## HTTP 状态码

状态码由三位数字组成，用来表示 HTTP 请求的结果。常见的状态码包括：

### 1xx 信息性响应

- **100 Continue**：继续。客户端应继续其请求。
- **101 Switching Protocols**：服务器根据客户端的请求切换协议。
- **102 Processing**：WebDAV 请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。

### 2xx 成功

- **200 OK**：请求成功，服务器已成功处理请求并提供请求的资源。
- **201 Created**：请求成功并且服务器创建了新的资源。
- **202 Accepted**：服务器已接受请求，但尚未处理完成。
- **203 Non-Authoritative Information**：服务器成功处理了请求，但返回的信息可能来自其他来源。
- **204 No Content**：服务器成功处理了请求，但没有返回内容。
- **205 Reset Content**：服务器成功处理了请求，客户端应重置视图。
- **206 Partial Content**：服务器成功处理了部分 GET 请求。
- **207 Multi-Status**：这是一个 WebDAV (Web Distributed Authoring and Versioning) 扩展状态码。服务器成功处理了请求，但返回的响应中可能包含多个资源的状态信息。响应主体通常是一个 XML 文件，其中描述了每个资源的状态，包括成功或失败的信息。这种状态码常用于 PROPFIND 或 PROPPATCH 请求，来表示多个独立操作的结果。

### 3xx 重定向

- **300 Multiple Choices**：请求的资源有多种选择，服务器提供了选项列表。
- **301 Moved Permanently**：请求的资源已永久移动到新的 URL。
- **302 Found**：请求的资源临时从不同的 URL 提供。
- **303 See Other**：客户端应使用 GET 请求到其他 URL 获取资源。
- **304 Not Modified**：资源未被修改，客户端可以继续使用[[缓存]]版本。
- **305 Use Proxy**：请求必须通过代理访问资源。
- **307 Temporary Redirect**：请求的资源临时从不同的 URL 提供，客户端应继续使用原始方法请求新 URL。
- **308 Permanent Redirect**：与 301 类似，但在 308 中，客户端必须继续使用原始请求方法（例如 POST 不会被转换为 GET）。这个状态码表示请求的资源已永久移动到新的 URL，客户端应使用新 URL 进行将来的请求，并且方法和消息体在重定向时不会改变。

### 4xx 客户端错误

- **400 Bad Request**：服务器无法理解请求的格式。
- **401 Unauthorized**：请求未授权，客户端需要提供身份验证。
- **402 Payment Required**：保留状态码，将来可能会用到。
- **403 Forbidden**：服务器拒绝请求，客户端无权访问资源。
- **404 Not Found**：请求的资源不存在。
- **405 Method Not Allowed**：请求方法对指定的资源不允许。
- **406 Not Acceptable**：服务器无法生成客户端请求的内容类型。
- **407 Proxy Authentication Required**：客户端必须先通过代理进行身份验证。
- **408 Request Timeout**：服务器等待客户端发送请求超时。
- **409 Conflict**：请求无法完成，因为请求的资源存在冲突。
- **410 Gone**：请求的资源已永久删除。
- **411 Length Required**：服务器需要客户端发送 Content-Length 头。
- **412 Precondition Failed**：服务器未满足请求中指定的前提条件。
- **413 Payload Too Large**：请求体大小超过了服务器的处理能力。
- **414 URI Too Long**：请求的 URI 太长，服务器无法处理。
- **415 Unsupported Media Type**：请求的媒体格式不受支持。
- **416 Range Not Satisfiable**：请求的范围无法满足，可能超出了资源的可用范围。
- **417 Expectation Failed**：服务器无法满足 Expect 请求头中的要求。
- **418 I'm a teapot**：典故性的错误代码，来自1998年愚人节的RFC 2324（“超文本咖啡壶控制协议”）。
- **421 Misdirected Request**：请求被定向到无法生成响应的服务器。
- **422 Unprocessable Entity**：请求格式正确，但由于语义错误，无法响应。
- **423 Locked**：资源已锁定。
- **424 Failed Dependency**：由于之前的请求失败，当前请求也无法完成。
- **425 Too Early**：服务器不愿意处理因为可能重放的请求。
- **426 Upgrade Required**：客户端应切换到 TLS/1.0。
- **428 Precondition Required**：服务器要求请求必须包含条件。
- **429 Too Many Requests**：客户端发送了太多请求，触发了速率限制。
- **431 Request Header Fields Too Large**：请求头字段太大，服务器拒绝处理。
- **451 Unavailable For Legal Reasons**：请求的资源因法律原因不可用。

### 5xx 服务器错误

- **500 Internal Server Error**：服务器遇到未定义的错误，无法处理请求。
- **501 Not Implemented**：服务器不支持请求的方法。
- **502 Bad Gateway**：服务器作为网关或代理时收到无效响应。
- **503 Service Unavailable**：服务器当前无法处理请求，通常是由于超载或维护。
- **504 Gateway Timeout**：服务器作为网关或代理时未能及时从上游服务器获得响应。
- **505 HTTP Version Not Supported**：服务器不支持请求所使用的 HTTP 版本。
- **506 Variant Also Negotiates**：服务器存在内部配置错误。
- **507 Insufficient Storage**：服务器无法存储完成请求所需的资源。
- **508 Loop Detected**：服务器检测到请求的资源存在无限循环。
- **510 Not Extended**：请求需要进一步扩展。
- **511 Network Authentication Required**：客户端需要进行网络认证。

## HTTP 版本

- **HTTP/1.0**：最早的 HTTP 版本，使用单个 [[TCP]] 连接完成每次请求-响应。
- **HTTP/1.1**：改进了连接管理和缓存控制，支持持久连接（连接复用），减少了连接的建立和关闭时间。
- **HTTP/2**：进一步提高了性能，支持多路复用（即多个请求可以在一个连接中并行进行）、头部压缩、服务器推送等。
- **HTTP/3**：基于 QUIC 协议的新一代 HTTP 版本，进一步减少了延迟，并改善了丢包情况下的性能。

## 缺陷

### 无状态性

HTTP 是无状态的协议，即每个请求都是独立的，服务器不会保留之前请求的状态。这种无状态性有助于简化服务器的设计，但也带来了一些问题：

- **状态管理困难**：对于需要保持会话状态的应用（如登录会话、购物车等），必须通过客户端（如 Cookie）或服务器端的机制（如会话管理）来维护状态，这增加了复杂性。
- **重复验证**：每次请求都需要进行身份验证，可能会增加不必要的网络开销。

### 安全性问题

HTTP 本身是一个明文传输协议，存在以下安全问题：

- **数据泄露**：由于数据是未加密传输的，攻击者可以通过中间人攻击（MITM）拦截并查看传输中的数据，导致隐私泄露。
- **篡改风险**：数据在传输过程中可能被篡改，攻击者可以修改请求或响应内容，导致严重的安全问题。
- **不验证身份**：HTTP 不提供服务器或客户端的身份验证，容易遭受钓鱼攻击或伪装攻击。

这些安全性问题通常通过 HTTPS（HTTP Secure）来缓解，但 HTTPS 也引入了额外的复杂性和性能开销。

### 性能问题

HTTP 尤其是早期版本（如 HTTP/1.0 和 HTTP/1.1）存在一些性能问题：

- **连接效率低**：HTTP/1.0 每次请求都需要建立一个新的 TCP 连接，增加了延迟。虽然 HTTP/1.1 引入了持久连接，但仍然存在连接复用效率低的问题。
- **队头阻塞（Head-of-line Blocking）**：在 HTTP/1.1 中，同一个连接上的请求必须按顺序处理，一个请求的延迟会阻塞后续请求的处理。
- **请求和响应开销大**：每个 HTTP 请求和响应都包含大量的头部信息，这些信息在不同请求中可能重复出现，增加了网络开销。虽然 HTTP/2 引入了头部压缩，但 HTTP/1.x 版本中的开销仍然是一个问题。

### 带宽和延迟问题

- **冗余数据传输**：由于 HTTP 是无状态的，可能会在多个请求中传输相同的头部信息和数据，浪费带宽。
- **高延迟**：每次请求都需要经历 DNS 解析、TCP 握手等步骤，这些步骤增加了网络延迟。对于内容丰富的网页，这些延迟可能会显著影响用户体验。

### 缓存控制复杂

虽然 HTTP 支持缓存，但缓存控制的配置和管理相对复杂。不同的缓存策略（如 Cache-Control、Expires、ETag 等）需要仔细配置，否则可能会导致缓存无效、数据过期或缓存未命中等问题。这可能会影响应用的性能和数据的及时性。

### 不支持多路复用

在 HTTP/1.1 之前的版本中，同一连接上只能发送一个请求，必须等到这个请求完成后才能发送下一个请求。这种单通道方式会导致队头阻塞，限制了并发请求的能力。HTTP/2 通过多路复用缓解了这个问题，但 HTTP/1.x 版本依然存在这一缺陷。

### 缺乏内置的优先级控制

HTTP 协议本身缺乏对请求优先级的控制机制。在一些情况下，比如当页面上有多个资源需要加载时（如 CSS 文件和图像），无法保证最重要的资源优先加载，从而影响页面的渲染速度和用户体验。HTTP/2 通过优先级控制和服务器推送解决了部分问题，但仍然存在局限性。

### 头部信息冗余

HTTP 请求和响应的头部信息往往包含大量重复和冗余的数据，如 User-Agent、Cookie 等。这些冗余数据在每次请求中都会重复传输，导致额外的带宽消耗。虽然 HTTP/2 通过头部压缩缓解了这一问题，但 HTTP/1.x 版本中这一缺陷依然存在。

### 延展性问题

随着 Web 应用的复杂性增加，HTTP 的基础设计显得不够灵活。例如，HTTP 不支持高效的实时通信，尽管有 WebSocket 这种协议扩展，但它与 HTTP 协议本身并不完全兼容，且需要额外的配置和处理。
