应用程序必须在内存中以执行，操作系统也必须在内存中以启动程序并处理程序运行期间发生的任何中断、 处理器异常或系统调用。因此内存不能被其他应用程序随意更改，必须保证一个进程只能修改分配给他的那一部分内存，否则就乱套了。

早期计算机为了实现内存保护有一个简单的机制，就是用两个额外的寄存器，就是基址和界限（base and bound）。基址指定进程在物理内存中的内存区域的起始位置，而界限给出其终点。这些寄存器只能被[[特权指令与非特权指令|特权指令]]更改，因此用户级代码不能改变他们的值。每次处理器执行指令时，它会检查程序计数器的地址、或是程序需要修改的内存地址是否在基址寄存器和界限寄存器之间。 如果是，则允许指令获取继续；否则，硬件会引发异常，挂起程序并将控制权转回操作系统内核。

但是很显然，只有用户模式下才需要这么干，内核模式下的指令被认为是完全可信的，因此不需要进行检查。

用物理地址基址和界限寄存器可以提供保护，但是这样一来会带来三个问题：
- 内存碎片化：当一个进程需要分配内存时，系统必须找到一块足够大的**连续**空闲区域。随着进程的创建、结束和内存的动态分配，内存中会出现许多大小不一的、不连续的空闲块，这些小块可能都无法满足新的进程需求，即使总的空闲内存足够大。
- 内存无法共享：每个进程都有自己独立的地址空间，并且这个地址空间是**连续且封闭**的。
- 动态增长和收缩困难：如果一个进程在运行时需要更多内存，它可能需要重新分配一个更大的**连续**内存块。这个过程可能很复杂，因为系统需要找到一个足够大的新区域，将旧数据复制到新区域，然后释放旧区域。如果找不到足够大的连续区域，进程可能会因为内存不足而终止。
- 缺乏细粒度保护：它只能保护一个进程不访问其分配空间之外的内存，但无法区分进程内部的不同区域。我们通常需要能够区分代码、数据和栈，并对它们应用不同的访问权限

为了解决以上的问题，现代处理器引入了一种间接层，就是虚拟地址。每个进程都有一个独立的**虚拟地址空间**，通常从 0 开始。这个空间是**线性的**，并且理论上可以非常大。当 CPU 想要访问一个**虚拟地址**时，它不会直接去物理内存中找。他会先将虚拟地址转换为物理地址，这个过程就叫做**地址转换**。这个转换过程的核心是一个叫做 **内存管理单元（MMU）** 的硬件。MMU 负责将虚拟地址**映射**到对应的**物理地址**。这个映射关系通常存储在一个叫做 **页表（Page Table）** 的数据结构中。页表由操作系统维护，它记录了虚拟地址空间中的**页（Page）** 与物理内存中的**页帧（Frame）** 之间的对应关系。

