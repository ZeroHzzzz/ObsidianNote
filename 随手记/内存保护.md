应用程序必须在内存中以执行，操作系统也必须在内存中以启动程序并处理程序运行期间发生的任何中断、 处理器异常或系统调用。因此内存不能被其他应用程序随意更改，必须保证一个进程只能修改分配给他的那一部分内存，否则就乱套了。

早期计算机为了实现内存保护有一个简单的机制，就是用两个额外的寄存器，就是基址和界限（base and bound）。基址指定进程在物理内存中的内存区域的起始位置，而界限给出其终点。这些寄存器只能被[[特权指令与非特权指令|特权指令]]更改，因此用户级代码不能改变他们的值。每次处理器执行指令时，它会检查程序计数器的地址、或是程序需要修改的内存地址是否在基址寄存器和界限寄存器之间。 如果是，则允许指令获取继续；否则，硬件会引发异常，挂起程序并将控制权转回操作系统内核。

但是很显然，只有用户模式下才需要这么干，内核模式下的指令被认为是完全可信的，因此不需要进行检查。

用物理地址基址和界限寄存器可以提供保护，但是这样一来会带来三个问题：
- 内存碎片化：当一个进程需要分配内存时，系统必须找到一块足够大的**连续**空闲区域。随着进程的创建、结束和内存的动态分配，内存中会出现许多大小不一的、不连续的空闲块，这些小块可能都无法满足新的进程需求，即使总的空闲内存足够大。
- 内存无法共享：每个进程都有自己独立的地址空间，并且这个地址空间是**连续且封闭**的。
- 动态增长和收缩困难：如果一个进程在运行时需要更多内存，它可能需要重新分配一个更大的**连续**内存块。这个过程可能很复杂，因为系统需要找到一个足够大的新区域，将旧数据复制到新区域，然后释放旧区域。如果找不到足够大的连续区域，进程可能会因为内存不足而终止。
- 缺乏细粒度保护：它只能保护一个进程不访问其分配空间之外的内存，但无法区分进程内部的不同区域。我们通常需要能够区分代码、数据和栈，并对它们应用不同的访问权限

为了解决以上的问题，现代处理器引入了一种间接层，就是虚拟地址。

