同样的，我们以v2rayA为例讲解一下几种防止[[DNS]]污染的方式。

## 使用远程 DNS 服务器（Remote DNS）

虽然这不是v2rayA里面的一个配置，但是这是最常见、最直接的方法。其原理就是你的设备不使用本地运营商的 DNS 服务器，而是直接向一个未被污染的远程 DNS 服务器（例如 Cloudflare 的 `1.1.1.1` 或 Google 的 `8.8.8.8`）发送 DNS 查询请求。v2rayA 会把这些 DNS 请求通过[[代理]]隧道发送，从而绕过本地 DNS 污染。

但是这有缺点，就是由于所有 DNS 查询都走了代理，你无法利用 DNS 结果进行本地分流。例如，如果 `goolge.com` 和 `qq.com` 都通过代理解析，那么即使你只想代理前者，后者也可能被误导。

## DNS 路由（DNS Routing）

DNS 路由是更高级、更智能的解决方案，它将 DNS 请求分流处理。v2rayA 会先用**本地 DNS 服务器**（例如 `223.5.5.5`）查询[[域名]]，然后用**远程 DNS 服务器**（例如 `1.1.1.1`）再查一遍。如果查询结果是国内 IP（例如 `1.2.3.4`），则认为该域名不需要代理，流量将直连。如果查询结果是国外 IP，或者本地 DNS 查询失败（可能被污染），v2rayA 就会使用远程 DNS 的结果，并把流量通过代理发送。

这种方法的优点就是可以区分国内外流量，能同时处理国内和国外的域名解析需求，实现精确的按需代理，避免不必要的流量代理，提高速度并节省资源。但是相应的你的 DNS 查询会先发送给本地 DNS 服务器，这可能会暴露你的部分浏览行为。

## DNS 协议加密（DoH / DoT）

这是从根本上防止 DNS 污染的方法。DoH（DNS over HTTPS）和 DoT（DNS over TLS）通过加密通道来传输 DNS 查询请求，使其看起来就像普通的 HTTPS 或 TLS 流量，从而让网络审查者无法识别和篡改 DNS 请求。但是这样加密和解密会带来轻微的延迟和性能开销，并且需要 DNS 服务器支持 DoH 或 DoT 协议。

### DoT

它工作在传输层，将传统的 DNS 查询（UDP/53 端口）封装在 **TLS/SSL 加密隧道**中。通常使用 **853 端口**。这种协议专用，更纯粹。但由于使用独立端口，容易被网络管理员识别和阻止，是一种“告诉所有人我在进行加密 DNS”的方式。

**原理流程**：

1. 你的设备向支持 DoT 的 DNS 服务器发起连接请求。
2. 双方建立一个安全的 TLS 加密隧道。
3. 你的 DNS 查询请求在这个加密隧道中以**密文**的形式传输。
4. 服务器返回的 DNS 解析结果也是密文。

### DoH

它工作在应用层。它将 DNS 查询封装成**HTTPS 请求**，并使用 **443 端口**。他将DNS流量伪装成普通网页流量，难以被识别和阻止，**抗审查能力更强**。但协议开销稍大。

**原理流程**：

1. 你的设备将 DNS 查询请求打包成一个 HTTPS 数据包。
2. 这个数据包通过标准的 HTTPS 协议发送给支持 DoH 的服务器。
3. 服务器收到请求后，解密数据包，执行 DNS 解析，然后将结果封装在另一个 HTTPS 数据包中返回。

## supervisor

这是v2rayA支持的一种特殊模式，用于解决特定类型的DNS污染问题。首先我们来看为什么需要这个东西。

在[[透明代理]]中，v2ray-core 默认会跳过那些被解析为**局域网或环回地址**（如 `127.0.0.1` 或 `10.0.0.1`）的流量。如果某个被污染的域名（比如 `google.com`）被恶意解析成 `127.0.0.1`，那么 v2ray 的域名嗅探（sniffing）功能就无法对其生效，导致该流量无法被代理。

对应的解决方法就是，v2rayA 使用 `iptables` 规则，拦截所有被污染到环回地址的 DNS 请求。同时，它使用 `pcap`（一种抓包工具）持续监控网卡流量，识别出那些被污染的域名。当它发现一个被污染的域名时，会“抢答”这个 DNS 请求，将其解析为一个**保留地址**。这样一来，这个流量就不再是环回地址，而是被强制导入 v2ray-core，v2ray-core 的域名嗅探功能就能正常处理它了。

这样虽然能够有效解决那些被污染成局域网或环回地址的特殊情况，但是相应地，持续使用 `pcap` 监控网卡会占用额外的 CPU 资源，因此在性能较低的设备（如路由器、嵌入式设备）或网络流量很大的场景下，可能会影响性能。

## FakeDNS

这个模式是为了解决**域名嗅探（sniffing）可能带来的兼容性问题**，提供一个不依赖嗅探的透明代理方案。这是因为v2ray 的域名嗅探功能需要解析 DNS 请求来判断流量的目的地，但有些应用程序（如 Tor、Telegram）的网络行为可能与嗅探机制发生冲突，导致代理失败或不稳定。

FakeDNS它不再依赖域名嗅探来判断流量，而是通过一个伪造的 DNS 服务器来处理请求。当设备发起 DNS 查询时，`fakedns` 会返回一个**假的 IP 地址**，这个假 IP 会被 v2ray-core 识别，并将其流量导入代理。v2ray-core 再根据流量中的域名信息来决定如何转发。

这种方法解决了域名嗅探与某些应用之间的冲突，提高了兼容性。但是这种方法会污染设备的 DNS [[缓存]]。当代理断开后，设备在一段时间内仍然会尝试访问那些假的 IP 地址，导致网络连接暂时中断。
