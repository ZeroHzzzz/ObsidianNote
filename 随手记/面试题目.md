网络流中的最大流问题

数据中心需要通过互联网将大量的数据从一个主服务器传输到多个用户终端。服务器和终端通过一组交换机互相连接，每条网络链路有带宽限制，表示数据包通过这条链路时的最大流量。为了最大化传输效率，你需要设计一个方案，使得从服务器传输到所有用户终端的总数据量最大化。

### Ford-Fulkerson 算法 福特福禄克森算法

#### 基本思想：

Ford-Fulkerson 是一种基于增广路径的贪心算法，用来解决最大流问题。它通过不断寻找从源点到汇点的可增广路径并在该路径上增加流量，直到无法找到新的增广路径为止。

#### 算法流程：

1. **初始化**：初始化所有边的流量为 0。
2. **寻找增广路径**：在残余网络中，找到一条从源点到汇点的增广路径。残余网络中的边容量为当前容量减去已使用的流量。
3. **增加流量**：沿着增广路径，计算该路径上的最小剩余容量（称为瓶颈容量），然后将该值加到路径上每条边的流量中，同时在反向边上增加相应的负流量。
4. **更新残余网络**：更新残余网络，继续寻找新的增广路径。
5. **终止条件**：当再也找不到增广路径时，算法终止，此时累加的流量即为最大流。

#### 时间复杂度：

Ford-Fulkerson 的时间复杂度依赖于寻找增广路径的方法。如果使用深度优先搜索 (DFS)，时间复杂度为 O(F⋅E)O(F \cdot E)O(F⋅E)，其中 FFF 是最大流的值，EEE 是边的数量。

#### 缺点：

如果边的容量是实数且每次增广增加的流量较小，Ford-Fulkerson 可能陷入无限循环，因此通常只用于边容量为整数的情况。

### Edmonds-Karp 算法 艾德蒙兹 卡普

#### 基本思想：

Edmonds-Karp 是 Ford-Fulkerson 算法的改进版本，它使用广度优先搜索 (BFS) 代替 DFS 来寻找增广路径，从而确保每次找到的增广路径长度最短。

#### 算法流程：

1. **初始化**：将所有边的流量初始化为 0。
2. **广度优先搜索（BFS）**：在残余网络中使用 BFS 寻找一条从源点到汇点的最短增广路径。
3. **计算瓶颈容量**：找到增广路径上最小的剩余容量，称为瓶颈容量。
4. **增加流量**：沿着增广路径增加流量，同时更新残余网络中的边容量和反向边的流量。
5. **重复搜索**：重复 BFS 寻找新的增广路径，直到没有可用路径为止。
6. **终止条件**：当无法找到增广路径时，算法结束，此时的累积流量即为最大流。

#### 时间复杂度：

Edmonds-Karp 的时间复杂度为 O(V⋅E2)O(V \cdot E^2)O(V⋅E2)，其中 VVV 是节点数，EEE 是边数。由于每条边最多参与 O(V)O(V)O(V) 次增广路径的更新，因此算法在每次 BFS 中最多需要 O(E)O(E)O(E) 的时间，总共进行 O(V)O(V)O(V) 次 BFS。

#### 优点：

BFS 保证了每次增广路径的长度最短，因此可以避免 Ford-Fulkerson 算法中的死循环问题，适用于所有边容量为整数或实数的情况。

### Dinic 算法 迪尼克算法

#### 基本思想：

Dinic 算法通过分层网络（level graph）和分层推进（blocking flow）的思想来加速最大流的求解。它使用 BFS 构建分层网络，然后在分层网络中使用 DFS 寻找阻塞流（blocking flow）。

#### 算法流程：

1. **初始化**：所有边的流量初始化为 0。
2. **构建分层网络**：
    - 使用 BFS 从源点出发，为每个节点分配层次，构建分层网络。分层网络中的每条边都连接相邻层次的节点，并且具有正的剩余容量。
    - 如果无法将汇点分配层次，说明无法找到增广路径，算法终止。
3. **寻找阻塞流（blocking flow）**：
    - 在分层网络中使用 DFS，寻找阻塞流。阻塞流是指从源点到汇点的所有路径上的最小剩余容量，使得每次找到的流量无法继续通过该路径增加流量。
    - 每次找到阻塞流后，更新残余网络，重复寻找新的阻塞流，直到在当前分层网络中无法找到任何阻塞流。
4. **重复构建分层网络**：当当前分层网络中的阻塞流都被找到并更新后，重新构建分层网络，继续查找新的阻塞流。
5. **终止条件**：当再也无法找到从源点到汇点的路径时，算法结束，此时的累积流量即为最大流。

#### 时间复杂度：

Dinic 算法的时间复杂度为 O(V2⋅E)O(V^2 \cdot E)O(V2⋅E) 在一般情况下，而在稀疏图中（即边的数量接近节点数量）表现更好，复杂度接近 O(V⋅E)O(V \cdot E)O(V⋅E)。

#### 优点：

Dinic 算法在大多数情况下比 Edmonds-Karp 算法更快，特别是在图较大且稀疏的情况下。它通过分层和阻塞流的方式减少了不必要的重复计算。

## Highest Label Preflow-Push

**HLPP（Highest Label Preflow-Push）** 是一种用于求解最大流问题的高效算法，属于**预流推进算法（Preflow-Push Algorithm）**家族。与经典的增广路径算法不同，预流推进算法使用“预流”的概念，通过逐步推动流量来找到最大流，并且不必遵循传统的增广路径的方式。

### 核心概念

1. **预流（Preflow）**：与普通流不同，预流允许某些节点的进入流量大于其流出的流量（即存在“溢出”）。因此，预流可以暂时违反流守恒性，只要最终结果满足流守恒性即可。
2. **高度（Height）**：每个节点都有一个与其关联的高度值，用于指导流量的推动方向。初始时，源点的高度设为图中节点数 nnn，而其他节点高度都设为 0。
3. **过量流量（Excess Flow）**：某个节点的进入流量大于其流出的流量时，该节点就有过量流量，表示可以继续推动流量。

### 算法流程

HLPP 算法的关键思想是每次从具有**最高高度**的溢出节点推动流量，直到所有的流量都被成功推到汇点。

#### 主要操作：

1. **初始化（Initialization）**：

    - 所有边的初始流量设为 0。
    - 源点的高度设置为节点数 nnn，所有其他节点的高度初始为 0。
    - 通过将源点的所有邻接边设置为其容量，形成初始的预流。

2. **推送操作（Push Operation）**：

    - 当节点 uuu 有过量流量时，如果节点 uuu 与节点 vvv 之间有剩余容量，并且 uuu 的高度高于 vvv 的高度，则可以将流量从 uuu 推向 vvv。
    - 推送的流量为 min⁡(过量流量,剩余容量)\min(\text{过量流量}, \text{剩余容量})min(过量流量,剩余容量)。
    - 更新节点 uuu 和 vvv 的过量流量，以及边的流量。

3. **提升操作（Relabel Operation）**：

    - 如果一个节点 uuu 有过量流量，但无法推送到任何相邻节点（即它的所有邻接节点的高度都不低于它），则将该节点的高度增加 1，以使其能够向更高的邻接节点推送流量。

4. **选择具有最高高度的节点（Highest Label Selection）**：

    - HLPP 算法的特点是始终选择具有最高高度的溢出节点进行推送操作。这种选择有助于加快收敛速度。

5. **循环执行推送和提升操作**：

    - 重复上述推送和提升操作，直到没有任何节点有过量流量，或者没有可执行的推送操作为止。

6. **终止条件**：

    - 当所有节点的过量流量都为 0 且没有可以推送的流量时，算法终止，汇点的流量即为最大流。

### 主要步骤总结

1. 初始化预流，从源点向相邻节点推送流量。
2. 重复选择具有最高高度的节点进行推送或提升操作。
3. 不断更新流量，直到没有节点有过量流量。

### 算法复杂度

HLPP 算法的时间复杂度是 O(V2⋅E)O(V^2 \cdot E)O(V2⋅E)，其中 VVV 是图中的节点数，EEE 是边数。在实际操作中，它通常比传统的 Ford-Fulkerson 或 Edmonds-Karp 算法更快，尤其是在图较为复杂或稠密的情况下。

### 优点

1. **高效性**：由于每次选择最高高度的节点推进流量，HLPP 通常比传统的增广路径算法更快，尤其在稠密图中表现优异。
2. **处理稠密图的能力强**：对于有大量边的稠密图，HLPP 算法的性能较好。

### 缺点

1. **内存占用较高**：与增广路径算法相比，HLPP 算法需要维护额外的高度和过量流量信息，因此内存占用会更高。
2. **不适合稀疏图**：在一些稀疏图或特定场景下，其他最大流算法（如 Dinic）可能表现更好。
