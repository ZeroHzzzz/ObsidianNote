公钥加密（Public Key Cryptography），也叫**非对称加密**（Asymmetric Cryptography），是一种非常重要的加密技术。它最核心的特点是使用**一对**不同的密钥来进行加密和解密。

在这个系统中，每个实体都有两把钥匙：

- 公钥（Public Key）：可以公开给所有人，用于**验证**签名。
- 私钥（Private Key）：只有发送者自己知道，用于**创建**签名。

公钥加密技术主要有两大用途：**加密数据**（保证隐私）和[[数字签名]]（保证身份和数据完整性）

## 加密数据（数据机密性）

就是为了确保只有接收者能阅读信息，即使信息在传输过程中被截获也无法被破解。发送者用接收者的**公钥**加密数据，然后接收者用自己的**私钥**解密。因为私钥是唯一的，只有接收者本人可以解密。

## 数字签名（身份验证和完整性）

这是为了证明数据确实来自某个特定的人，并且在传输过程中没有被篡改。发送者用自己的**私钥**对数据进行签名，接收者用发送者的**公钥**来验证这个签名。如果验证成功，就证明数据的真实性和完整性。

## 常用的公钥加密算法

公钥加密是一个总称，它有多种不同的实现算法，每种算法都基于不同的数学难题。

### RSA

首先最常见的就是RSA技术。原理就是基于**大整数因式分解**的困难性。也就是说，一个非常大的合数，很难被分解成它的两个质因数。

这种方法非常常见，历史悠久。但是，为了保证安全性，密钥长度需要越来越长，这会导致性能下降。

### ECC（椭圆曲线加密）

原理就是基于**椭圆曲线离散对数**的困难性。在相同的安全强度下，ECC 的密钥长度比 RSA 短得多。这使得它在计算资源有限的设备（如手机、物联网设备）上更高效。现代许多加密协议（如 TLS 1.3）都优先使用 ECC。

### DSA（数字签名算法）

这种算法是基于离散对数的困难性。它专门用于**数字签名**，不能用于加密数据。DSA 通常用于对软件更新或证书进行签名，以验证其真实性。

欸这里就有问题了，为啥说他不能用于加密数据？他签名本身不就是拿私钥对哈希出来的结果去加密，然后后面再用公钥解出来和哈希去比对，那他不就是加密解密？

这是我才疏学浅，才会出现这个问题。

这首先涉及到我们对于这个加密解密概念的理解。“签名”这个动作确实包含了一次**私钥加密**的过程。但是，在密码学中，我们通常不会把这个过程称为“加密”，因为它的目的和最终结果与传统的加密不同。

加密是为了**隐藏信息**，确保除了预期的接收者之外，没有人能够看到信息的原始内容。加密的数据在解密后，会还原成可读的原文。而签名的目的是**验证身份**和**数据完整性**。签名本身不是为了隐藏信息，它只是一个**验证码**。即使你解密了签名，得到的结果也只是一个哈希值，你无法从中还原出原始数据，也无法获取任何机密信息。

DSA 签名确实是“用私钥对哈希值进行数学运算”。这个运算在技术上可以被看作是加密，因为只有匹配的公钥才能解密。但是，这个加密有一个关键特点，加密的不是原始数据，而是**数据的哈希值**。哈希值是单向的，无法从哈希值逆向计算出原始数据。解密后得到的结果是哈希值，它没有秘密可言，只是一个用来比对的“指纹”。它无法提供任何信息。

因此，在密码学领域，我们区分了这两种操作：

- 用公钥加密、私钥解密，目的是**隐藏信息**，这叫做**加密**。
- 用私钥签名、公钥验证，目的是**验证信息**，这叫做**数字签名**。

那我又迷惑了，你私钥拿去算这个哈希值，然后你不能拿公钥解算出来，那你怎么验证？

我们先来看看DSA算法过程。

首先我们需要一个签名。你用你的**私钥**对哈希值进行数学运算，得到签名 **(r, s)**。这个签名 **(r, s)** 并不是加密后的哈希值，而是一对基于**离散对数问题**的特定数学解。当我拿到你的签名 **(r, s)** 和你的**公钥**时，我不需要去“解密”任何东西。我会用你的公钥、签名、以及我独立计算的哈希值，代入一个**预定的数学等式**中，**如果这个等式成立**，那么就证明你的签名是有效的；**如果等式不成立**，那么签名就是无效的。这就是验证的过程。

这个过程的关键是，**我不需要知道你的私钥**，也不需要将你的签名“解密”回原始的哈希值。我只需要用你的公钥，来验证这个等式是否成立。这个过程和RSA、ECC这些算法有所不同。

一句话概括：**DSA是验证等式成立，和RSA、ECC算法这种加解密方法不同。**
